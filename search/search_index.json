{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NickySpatial","text":"<p>An open-source object-based image analysis library for remote sensing.</p> Category Badge Build Code Quality Documentation Package Info Community <p>[!WARNING] This project is under active development and lot of its functionality is still in my head yet to code.</p>"},{"location":"#description","title":"Description","text":"<p>NickySpatial is a Python package that provides object-based image analysis (OBIA) functionality similar to commercial software like eCognition. It allows users to segment geospatial imagery into meaningful objects, calculate statistics, and apply rule-based classification.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>nickyspatial/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 io/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 raster.py       # Raster I/O\n\u2502   \u2514\u2500\u2500 vector.py       # Vector I/O\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 layer.py        # Layer class and management\n\u2502   \u251c\u2500\u2500 segmentation.py # Segmentation algorithms\n\u2502   \u2514\u2500\u2500 rules.py        # Rule engine\n\u251c\u2500\u2500 stats/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 basic.py        # Basic statistics (min, max, mean, etc.)\n\u2502   \u251c\u2500\u2500 spatial.py      # Spatial statistics (area, perimeter, etc.)\n\u2502   \u2514\u2500\u2500 spectral.py     # Spectral indices (NDVI, etc.)\n\u251c\u2500\u2500 filters/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 spatial.py      # Spatial filters (smoothing, merging)\n\u2502   \u2514\u2500\u2500 spectral.py     # Spectral filters (band math)\n\u251c\u2500\u2500 viz/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 maps.py         # Map visualization\n\u2502   \u2514\u2500\u2500 charts.py       # Statistical charts\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 helpers.py      # Helper functions\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nickyspatial\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import nickyspatial as ns\n TODO : add sample computation here\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed documentation and examples, see the documentation website.</p>"},{"location":"#examples","title":"Examples","text":"<p>Check out the examples directory for more examples:</p> <p>TODO : Add example scripts here</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Follow dev setup guide &amp; Please feel free to submit a Pull Request.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Inspired by the functionality of eCognition and other OBIA methodologies</li> <li>Built on top of powerful open-source libraries like numpy, rasterio, scikit-image, and GeoPandas</li> </ul>"},{"location":"#nicky","title":"Nicky","text":"<p>Nicky is my belated dog and I named this package on his memory !</p> <p></p>"},{"location":"dev/","title":"Development Setup","text":"<p>Welcome to the development guide for nickyspatial! This guide will help you get up and running quickly, while also explaining the tools and processes we use.</p>"},{"location":"dev/#1-install-uv","title":"1. Install UV","text":"<p>We use UV because it is freaking fast and simplifies dependency management. UV streamlines the installation and synchronization of dependencies, making development smoother and more efficient.</p> <p>Install UV by running:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"dev/#2-sync-project-dependencies","title":"2. Sync Project Dependencies","text":"<p>Once UV is installed, install the project dependencies directly into your virtual environment (<code>.venv</code>) with:</p> <pre><code>uv sync\n</code></pre> <p>This command reads project's configuration (i.e. <code>pyproject.toml</code>) and ensures that all required libraries are installed with the correct versions.</p>"},{"location":"dev/#3-install-pre-commit-hooks","title":"3. Install Pre-commit Hooks","text":"<p>We use pre-commit hooks to ensure code quality and consistency across the project. Our pre-commit configuration includes:</p> <ul> <li>UV Lock: Ensures locking of dependency versions.</li> <li>Ruff Hooks (linter and formatter): Ruff is used for linting and formatting. It helps catch issues and enforces a consistent code style.</li> <li>Commitizen: Helps enforce conventional commit messages for better project history.</li> </ul> <p>To set up these hooks, run:</p> <pre><code>pre-commit install\n</code></pre> <p>This will automatically run the following on every commit:</p> <ul> <li>uv-lock: Validates your UV lock file.</li> <li>ruff: Checks code style and formatting.</li> <li>commitizen: Validates commit messages against the conventional commits specification.</li> </ul>"},{"location":"dev/#4-getting-started","title":"4. Getting Started","text":"<p>Once you have UV installed, dependencies synced, and pre-commit hooks set, you\u2019re ready for development. A typical workflow might look like:</p> <ul> <li>Work on a feature or bug fix. Just tell other people what you will be working on in issues</li> <li>Run your tests \u2013 our project uses Pytest for testing.</li> <li>Commit your changes \u2013 pre-commit hooks ensure that your code meets our quality standards and that your commit messages follow the Conventional Commits guidelines.</li> <li>Submit your PR - Create a branch with suitable name as per as your changes and raise PR</li> </ul>"},{"location":"examples/simple_usecase/","title":"nickyspatial Workflow Example","text":"In\u00a0[\u00a0]: Copied! <pre>! pip install nickyspatial\n</pre> ! pip install nickyspatial In\u00a0[1]: Copied! <pre>import os\nimport requests\nimport matplotlib.pyplot as plt\n\nfrom nickyspatial import (\n    LayerManager,\n    MultiResolutionSegmentation,\n    RuleSet,\n    attach_ndvi,\n    attach_shape_metrics,\n    attach_spectral_indices,\n    layer_to_raster,\n    layer_to_vector,\n    plot_classification,\n    plot_layer,\n    read_raster,\n)\n\noutput_dir = \"output\"\nos.makedirs(output_dir, exist_ok=True)\n\n\ndata_dir = \"data\"\nos.makedirs(data_dir, exist_ok=True)\n\nraster_path = os.path.join(data_dir, \"sample.tif\")\n\nif not os.path.exists(raster_path):\n    url = \"https://github.com/kshitijrajsharma/nickyspatial/raw/refs/heads/master/data/sample.tif\"\n    print(f\"Downloading sample raster from {url}...\")\n    response = requests.get(url)\n    response.raise_for_status()  # Ensure the download succeeded\n    with open(raster_path, \"wb\") as f:\n        f.write(response.content)\n    print(f\"Downloaded sample raster to {raster_path}\")\nelse:\n    print(f\"Using existing raster at: {raster_path}\")\n</pre> import os import requests import matplotlib.pyplot as plt  from nickyspatial import (     LayerManager,     MultiResolutionSegmentation,     RuleSet,     attach_ndvi,     attach_shape_metrics,     attach_spectral_indices,     layer_to_raster,     layer_to_vector,     plot_classification,     plot_layer,     read_raster, )  output_dir = \"output\" os.makedirs(output_dir, exist_ok=True)   data_dir = \"data\" os.makedirs(data_dir, exist_ok=True)  raster_path = os.path.join(data_dir, \"sample.tif\")  if not os.path.exists(raster_path):     url = \"https://github.com/kshitijrajsharma/nickyspatial/raw/refs/heads/master/data/sample.tif\"     print(f\"Downloading sample raster from {url}...\")     response = requests.get(url)     response.raise_for_status()  # Ensure the download succeeded     with open(raster_path, \"wb\") as f:         f.write(response.content)     print(f\"Downloaded sample raster to {raster_path}\") else:     print(f\"Using existing raster at: {raster_path}\") <pre>Using existing raster at: data/sample.tif\n</pre> In\u00a0[2]: Copied! <pre>image_data, transform, crs = read_raster(raster_path)\nprint(f\"Image dimensions: {image_data.shape}\")\nprint(f\"Coordinate system: {crs}\")\n</pre> image_data, transform, crs = read_raster(raster_path) print(f\"Image dimensions: {image_data.shape}\") print(f\"Coordinate system: {crs}\") <pre>Image dimensions: (4, 877, 1164)\nCoordinate system: EPSG:32654\n</pre> In\u00a0[3]: Copied! <pre>manager = LayerManager()\n\nsegmenter = MultiResolutionSegmentation(scale=40, compactness=1)\nsegmentation_layer = segmenter.execute(\n    image_data,\n    transform,\n    crs,\n    layer_manager=manager,\n    layer_name=\"Base_Segmentation\",\n)\n\nprint(\"Segmentation layer created:\")\nprint(segmentation_layer)\n</pre> manager = LayerManager()  segmenter = MultiResolutionSegmentation(scale=40, compactness=1) segmentation_layer = segmenter.execute(     image_data,     transform,     crs,     layer_manager=manager,     layer_name=\"Base_Segmentation\", )  print(\"Segmentation layer created:\") print(segmentation_layer) <pre>Number of segments: 638\nSegmentation layer created:\nLayer 'Base_Segmentation' (type: segmentation, parent: None, objects: 638)\n</pre> In\u00a0[4]: Copied! <pre>fig1 = plot_layer(segmentation_layer, image_data, rgb_bands=(3, 2, 1), show_boundaries=True)\nplt.show()\n\nfig1.savefig(os.path.join(output_dir, \"1_segmentation.png\"))\n</pre> fig1 = plot_layer(segmentation_layer, image_data, rgb_bands=(3, 2, 1), show_boundaries=True) plt.show()  fig1.savefig(os.path.join(output_dir, \"1_segmentation.png\")) In\u00a0[5]: Copied! <pre>segmentation_layer.attach_function(\n    attach_ndvi,\n    name=\"ndvi_stats\",\n    nir_column=\"band_4_mean\",\n    red_column=\"band_3_mean\",\n    output_column=\"NDVI\",\n)\n\nsegmentation_layer.attach_function(\n    attach_spectral_indices,\n    name=\"spectral_indices\",\n    bands={\n        \"blue\": \"band_1_mean\",\n        \"green\": \"band_2_mean\",\n        \"red\": \"band_3_mean\",\n        \"nir\": \"band_4_mean\",\n    },\n)\n\nfig2 = plot_layer(segmentation_layer, attribute=\"NDVI\", title=\"NDVI Values\", cmap=\"RdYlGn\")\nplt.show()\n\nfig2.savefig(os.path.join(output_dir, \"2_ndvi.png\"))\n</pre> segmentation_layer.attach_function(     attach_ndvi,     name=\"ndvi_stats\",     nir_column=\"band_4_mean\",     red_column=\"band_3_mean\",     output_column=\"NDVI\", )  segmentation_layer.attach_function(     attach_spectral_indices,     name=\"spectral_indices\",     bands={         \"blue\": \"band_1_mean\",         \"green\": \"band_2_mean\",         \"red\": \"band_3_mean\",         \"nir\": \"band_4_mean\",     }, )  fig2 = plot_layer(segmentation_layer, attribute=\"NDVI\", title=\"NDVI Values\", cmap=\"RdYlGn\") plt.show()  fig2.savefig(os.path.join(output_dir, \"2_ndvi.png\")) In\u00a0[6]: Copied! <pre>segmentation_layer.attach_function(attach_shape_metrics, name=\"shape_metrics\")\n\nseg_geojson_path = os.path.join(output_dir, \"segmentation.geojson\")\nlayer_to_vector(segmentation_layer, seg_geojson_path)\nprint(f\"Segmentation GeoJSON saved to {seg_geojson_path}\")\n</pre> segmentation_layer.attach_function(attach_shape_metrics, name=\"shape_metrics\")  seg_geojson_path = os.path.join(output_dir, \"segmentation.geojson\") layer_to_vector(segmentation_layer, seg_geojson_path) print(f\"Segmentation GeoJSON saved to {seg_geojson_path}\") <pre>Segmentation GeoJSON saved to output/segmentation.geojson\n</pre> In\u00a0[7]: Copied! <pre>land_cover_rules = RuleSet(name=\"Land_Cover\")\nland_cover_rules.add_rule(name=\"Vegetation\", condition=\"NDVI &gt; 0.2\")\nland_cover_rules.add_rule(name=\"Other\", condition=\"NDVI &lt;= 0.2\")\n\nland_cover_layer = land_cover_rules.execute(\n    segmentation_layer,\n    layer_manager=manager,\n    layer_name=\"Land_Cover\",\n)\n\nfig3 = plot_classification(land_cover_layer, class_field=\"classification\")\nplt.show()\n\nfig3.savefig(os.path.join(output_dir, \"3_land_cover.png\"))\n</pre> land_cover_rules = RuleSet(name=\"Land_Cover\") land_cover_rules.add_rule(name=\"Vegetation\", condition=\"NDVI &gt; 0.2\") land_cover_rules.add_rule(name=\"Other\", condition=\"NDVI &lt;= 0.2\")  land_cover_layer = land_cover_rules.execute(     segmentation_layer,     layer_manager=manager,     layer_name=\"Land_Cover\", )  fig3 = plot_classification(land_cover_layer, class_field=\"classification\") plt.show()  fig3.savefig(os.path.join(output_dir, \"3_land_cover.png\")) In\u00a0[8]: Copied! <pre>vegetation_rules = RuleSet(name=\"Vegetation_Types\")\nvegetation_rules.add_rule(\n    name=\"Healthy_Vegetation\",\n    condition=\"(classification == 'Vegetation') &amp; (NDVI &gt; 0.6)\",\n)\nvegetation_rules.add_rule(\n    name=\"Moderate_Vegetation\",\n    condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.6) &amp; (NDVI &gt; 0.4)\",\n)\nvegetation_rules.add_rule(\n    name=\"Sparse_Vegetation\",\n    condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.4)\",\n)\n\nvegetation_layer = vegetation_rules.execute(\n    land_cover_layer,\n    layer_manager=manager,\n    layer_name=\"Vegetation_Types\",\n    result_field=\"veg_class\",\n)\n\nfig4 = plot_classification(vegetation_layer, class_field=\"veg_class\")\nplt.show()\n\nfig4.savefig(os.path.join(output_dir, \"4_vegetation_types.png\"))\n</pre> vegetation_rules = RuleSet(name=\"Vegetation_Types\") vegetation_rules.add_rule(     name=\"Healthy_Vegetation\",     condition=\"(classification == 'Vegetation') &amp; (NDVI &gt; 0.6)\", ) vegetation_rules.add_rule(     name=\"Moderate_Vegetation\",     condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.6) &amp; (NDVI &gt; 0.4)\", ) vegetation_rules.add_rule(     name=\"Sparse_Vegetation\",     condition=\"(classification == 'Vegetation') &amp; (NDVI &lt;= 0.4)\", )  vegetation_layer = vegetation_rules.execute(     land_cover_layer,     layer_manager=manager,     layer_name=\"Vegetation_Types\",     result_field=\"veg_class\", )  fig4 = plot_classification(vegetation_layer, class_field=\"veg_class\") plt.show()  fig4.savefig(os.path.join(output_dir, \"4_vegetation_types.png\")) In\u00a0[9]: Copied! <pre>land_cover_geojson = os.path.join(output_dir, \"land_cover.geojson\")\nvegetation_geojson = os.path.join(output_dir, \"vegetation_types.geojson\")\n\nlayer_to_vector(land_cover_layer, land_cover_geojson)\nlayer_to_vector(vegetation_layer, vegetation_geojson)\n\nland_cover_raster = os.path.join(output_dir, \"land_cover.tif\")\nlayer_to_raster(land_cover_layer, land_cover_raster, column=\"classification\")\n\nprint(f\"Land cover GeoJSON saved to {land_cover_geojson}\")\nprint(f\"Vegetation GeoJSON saved to {vegetation_geojson}\")\nprint(f\"Land cover raster saved to {land_cover_raster}\")\n\n# List all available layers from the manager\nprint(\"\\nAvailable layers:\")\nfor i, layer_name in enumerate(manager.get_layer_names(), start=1):\n    print(f\"  {i}. {layer_name}\")\n</pre> land_cover_geojson = os.path.join(output_dir, \"land_cover.geojson\") vegetation_geojson = os.path.join(output_dir, \"vegetation_types.geojson\")  layer_to_vector(land_cover_layer, land_cover_geojson) layer_to_vector(vegetation_layer, vegetation_geojson)  land_cover_raster = os.path.join(output_dir, \"land_cover.tif\") layer_to_raster(land_cover_layer, land_cover_raster, column=\"classification\")  print(f\"Land cover GeoJSON saved to {land_cover_geojson}\") print(f\"Vegetation GeoJSON saved to {vegetation_geojson}\") print(f\"Land cover raster saved to {land_cover_raster}\")  # List all available layers from the manager print(\"\\nAvailable layers:\") for i, layer_name in enumerate(manager.get_layer_names(), start=1):     print(f\"  {i}. {layer_name}\") <pre>Mapping categorical values: {'Vegetation': 0, 'Other': 1}\nLand cover GeoJSON saved to output/land_cover.geojson\nVegetation GeoJSON saved to output/vegetation_types.geojson\nLand cover raster saved to output/land_cover.tif\n\nAvailable layers:\n  1. Base_Segmentation\n  2. Land_Cover\n  3. Vegetation_Types\n</pre>"},{"location":"examples/simple_usecase/#nickyspatial-workflow-example","title":"nickyspatial Workflow Example\u00b6","text":"<p>In this notebook we demonstrate how to use the <code>nickyspatial</code> library to read a raster, perform segmentation, calculate spectral indices (like NDVI), and apply rule-based classification. We then display the resulting figures inline. This example explains how rules are applied to classify segments.</p>"},{"location":"examples/simple_usecase/#setup-imports","title":"Setup &amp; Imports\u00b6","text":"<p>We begin by importing the required modules and setting up the environment. &amp; Download the sample quickbird satellite image for our module</p>"},{"location":"examples/simple_usecase/#reading-the-raster","title":"Reading the Raster\u00b6","text":"<p>We now read the raster data and print some basic information about the image.</p>"},{"location":"examples/simple_usecase/#performing-segmentation","title":"Performing Segmentation\u00b6","text":"<p>Here we perform multi-resolution segmentation. A <code>LayerManager</code> is used to keep track of all layers created in the process. nickyspatial packages uses a layer object which is an underlying vector segmentation tied up to the raster , similar concept as layer in ecognition</p>"},{"location":"examples/simple_usecase/#visualizing-segmentation","title":"Visualizing Segmentation\u00b6","text":"<p>We utilize the built-in plotting function to visualize the segmentation. The image will be displayed inline.</p>"},{"location":"examples/simple_usecase/#calculating-spectral-indices-ndvi","title":"Calculating Spectral Indices (NDVI)\u00b6","text":"<p>Next, we attach functions to the segmentation layer to calculate NDVI and other spectral indices. NDVI is a common metric to assess vegetation health. Here we are doing an example how to use the existing pre-defined rules in the library</p>"},{"location":"examples/simple_usecase/#calculating-shape-metrics","title":"Calculating Shape Metrics\u00b6","text":"<p>In this step, we attach a function to calculate shape index of objects and export the segmentation results as a GeoJSON file.</p>"},{"location":"examples/simple_usecase/#applying-land-cover-classification-rules","title":"Applying Land Cover Classification Rules\u00b6","text":"<p>Now we demonstrate how to use rule-based classification. Rules are defined for the land cover classification. For example, we can define a rule that marks segments as <code>Vegetation</code> if their NDVI is greater than 0.2; all other segments are marked as <code>Other</code>. With this technique we define our custom rule which can be in hierarchical order We then generate a classified layer and visualize the results.</p>"},{"location":"examples/simple_usecase/#applying-hierarchical-classification-rules","title":"Applying Hierarchical Classification Rules\u00b6","text":"<p>For further refinement, we can apply hierarchical rules. In this example, we subdivide the <code>Vegetation</code> class into categories such as <code>Healthy_Vegetation</code>, <code>Moderate_Vegetation</code>, and <code>Sparse_Vegetation</code> based on NDVI thresholds.</p> <p>This demonstrates how you can build upon basic classifications to obtain more granular information.</p>"},{"location":"examples/simple_usecase/#exporting-and-reviewing-results","title":"Exporting and Reviewing Results\u00b6","text":"<p>Finally we export the land cover and vegetation layers as GeoJSON and raster, and print out the available layers from the manager.</p>"},{"location":"examples/simple_usecase/#summary","title":"Summary\u00b6","text":"<p>In this notebook we:</p> <ul> <li>Loaded a sample raster image.</li> <li>Performed segmentation on the raster.</li> <li>Calculated spectral indices (NDVI) and attached additional functions.</li> <li>Applied basic and hierarchical rule-based classifications to derive land cover types.</li> <li>Displayed the figures inline and exported the results for further analysis.</li> </ul> <p>This example demonstrates how rule-based functions can be integrated for remote sensing and image analysis workflows using the nickyspatial library.</p>"}]}